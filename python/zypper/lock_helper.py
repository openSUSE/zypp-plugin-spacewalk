#
# Copyright (c) 2013 Novell, Inc.
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, contact Novell, Inc.
#
# To contact Novell about this file by physical or electronic mail,
# you may find current contact information at www.novell.com
#
# Author: Flavio Castelli <fcastelli@suse.com>
#

import string

def read_lock_file(lock_file):
    """ Parses the file containing all the zypper locks and returns them as an
        list of dict
    """

    locks = []

    with open(lock_file) as f:
        lock = {}
        for line in f:
            if not line.strip():
                if lock.keys():
                    locks.append(lock)
                    lock = {}
            elif line[0] != "#":
                key, value = string.split(line.strip(), ":", 2)
                lock[key.strip()] = value.strip()

        if lock.keys():
            locks.append(lock)

        return locks

def write_lock_file(locks, file_name):
    """ Write the locks to disk. """

    with open(file_name, 'w') as f:
        f.write('# Generated by zypp-plugin-spacewalk:packages.setLocks action\n')
        f.write('# Do not edit! Changes will be lost!\n')

        for lock in locks:
            f.write('\n')
            for key in lock:
                f.write('{0}: {1}\n'.format(key, lock[key]))

def lock_solvable(locks, solvable_name):
    """ Adds a satellite lock to the existing locks. """

    matches = filter( lambda l: l.has_key('solvable_name') and l['solvable_name'] == solvable_name,
                      locks)

    for match in matches:
        locks.remove(match)

    locks.append(
        {
            'type'           : 'package',
            'match_type'     : 'exact',
            'case_sensitive' : 'on',
            'solvable_name'  : solvable_name
        }
    )

def unlock_solvable(locks, solvable_name):
    """ Removes the lock affecting a solvable. """

    matches = filter( lambda l: l.has_key('solvable_name') and l['solvable_name'] == solvable_name,
                      locks)

    for match in matches:
        locks.remove(match)

